### Rollup 打包的基本概念

#### 快速上手

首先让我们用 `npm init -y` 新建一个项目，然后安装 `rollup` 依赖：

```shell
pnpm init

pmpm i rollup
```

接着新增 src/index.js 和 src/util.js 和 rollup.config.js 三个文件，目录结构如下所示:

```txt
├── package.json
├── pnpm-lock.yaml
├── rollup.config.js
└── src
 ├── index.js
 └── util.js
```

文件的内容分别如下：

```js
// src/index.js
import { add } from './util'
console.log(add(1, 2))

// src/util.js
export const add = (a, b) => a + b
export const multi = (a, b) => a * b

// rollup.config.js
// 以下注释是为了能使用 VSCode 的类型提示
/**
 * @type { import('rollup').RollupOptions }
 */
const buildOptions = {
  input: ['src/index.js'],
  output: {
    // 产物输出目录
    dir: 'dist/es',
    // 产物格式
    format: 'esm'
  }
}
export default buildOptions
```

你可以在 `package.json` 中加入如下的构建脚本：

```json
{
  // rollup 打包命令，`-c` 表示使用配置文件中的配置
  "build": "rollup -c"
}
```

接着在终端执行一下 npm run build ，可以看到如下的命令行信息:

![Snipaste_2023-11-08_10-25-53.png](https://s2.loli.net/2023/11/08/KfimCLRQehSX2pd.png)

OK，现在你已经成功使用 Rollup 打出了第一份产物! 我们可以去 dist/es 目录查看一下产物的内容:

```js
// dist/es/index.js
const add = (a, b) => a + b

console.log(add(1, 2))
```

同时你也可以发现， `util.js ` 中的 `multi` 方法并没有被打包到产物中，这是因为 Rollup 具有天然的 `Tree Shaking` 功能，可以分析出未使用到的模块并自动擦除。

所谓 `Tree Shaking` (摇树)，也是计算机编译原理中 `DCE` (Dead Code Elimination，即消除无用代码) 技术的一种实现。由于 ES 模块依赖关系是确定的，和运行时状态无关。因此 Rollup 可以在编译阶段分析出依赖关系，对 AST 语法树中没有使用到的节点进行删除，从而实现 Tree Shaking。

#### 常用配置解读

##### 1.多产物配置

在打包 JavaScript 类库的场景中，我们通常需要对外暴露出不同格式的产物供他人使用，不仅包括 `ESM` ，也需要包括诸如 `CommonJS` 、 `UMD` 等格式，保证良好的兼容性。那么，同一份入口文件，如何让 Rollup 给我们打包出不一样格式的产物呢？我们基于上述的配置文件来进行修改:

```js
// rollup.config.js
/**
 * @type { import('rollup').RollupOptions }
 */

const buildOptions = {
  input: ['src/index.js'],
  output: [
    {
      dir: 'dist/es',
      format: 'esm'
    },
    {
      dir: 'dist/cjs',
      format: 'cjs'
    }
  ]
}

export default buildOptions
```

从代码中可以看到，我们将 output 属性配置成一个数组，数组中每个元素都是一个描述对象，决定了不同产物的输出行为。

##### 2.多入口配置

除了多产物配置，Rollup 中也支持多入口配置，而且通常情况下两者会被结合起来使用。接下来，就让我们继续改造之前的配置文件，将 input 设置为一个数组或者一个对象，如下所示:

```js
{
 input: ["src/index.js", "src/util.js"]
}
// 或者
{
 input: {
 index: "src/index.js",
 util: "src/util.js",
 },
}
```

通过执行 npm run build 可以发现，所有入口的不同格式产物已经成功输出:

![Snipaste_2023-11-08_10-34-12.png](https://s2.loli.net/2023/11/08/nC3BDP4ydL5iafs.png)

如果不同入口对应的打包配置不一样，我们也可以默认导出一个配置数组，如下所示：

```js
// rollup.config.js
/**
 * @type { import('rollup').RollupOptions }
 */
const buildIndexOptions = {
  input: ['src/index.js'],
  output: [
    // 省略 output 配置
  ]
}
/**
 * @type { import('rollup').RollupOptions }
 */
const buildUtilOptions = {
  input: ['src/util.js'],
  output: [
    // 省略 output 配置
  ]
}
export default [buildIndexOptions, buildUtilOptions]
```

如果是比较复杂的打包场景(如 [Vite 源码本身的打包](https://github.com/vitejs/vite/blob/main/packages/vite/rollup.config.ts))，我们需要将项目的代码分成几个部分，用不同的 Rollup 配置分别打包，这种配置就很有用了。

##### 3.自定义 output 配置

刚才我们提到了 input 的使用，主要用来声明入口，可以配置成字符串、数组或者对象，使用比较简单。而 output 与之相对，用来配置输出的相关信息，常用的配置项如下:

```js
output: {
 // 产物输出目录
 dir: path.resolve(__dirname, 'dist'),
 // 以下三个配置项都可以使用这些占位符:
 // 1. [name]: 去除文件后缀后的文件名
 // 2. [hash]: 根据文件名和文件内容生成的 hash 值
 // 3. [format]: 产物模块格式，如 es、cjs
 // 4. [extname]: 产物后缀名(带`.`)
 // 入口模块的输出文件名
 entryFileNames: `[name].js`,
 // 非入口模块(如动态 import)的输出文件名
 chunkFileNames: 'chunk-[hash].js',
 // 静态资源文件输出文件名
 assetFileNames: 'assets/[name]-[hash][extname]',
 // 产物输出格式，包括`amd`、`cjs`、`es`、`iife`、`umd`、`system`
 format: 'cjs',
 // 是否生成 sourcemap 文件
 sourcemap: true,
 // 如果是打包出 iife/umd 格式，需要对外暴露出一个全局变量，通过 name 配置变量名
 name: 'MyBundle',
 // 全局变量声明
 globals: {
 // 项目中可以直接用`$`代替`jquery`
 jquery: '$'
 }
}
```

##### 4.依赖 external

对于某些第三方包，有时候我们不想让 Rollup 进行打包，也可以通过 external 进行外部化：

```js
{
  external: ['react', 'react-dom']
}
```

##### 5.接入插件能力

在 Rollup 的日常使用中，我们难免会遇到一些 Rollup 本身不支持的场景，比如 `兼容CommonJS 打包`、`注入环境变量`、`配置路径别名`、`压缩产物代码` 等等。这个时候就需要我们引入相应的 Rollup 插件了。接下来以一个具体的场景为例带大家熟悉一下 Rollup 插件的使用。

虽然 Rollup 能够打包 `输出` 出 `CommonJS` 格式的产物，但对于 `输入` 给 Rollup 的代码并不支持 CommonJS，仅仅支持 ESM。你可能会说，那我们直接在项目中统一使用 ESM 规范就可以了啊，这有什么问题呢？需要注意的是，我们不光要考虑项目本身的代码，还要考虑第三方依赖。目前为止，还是有不少第三方依赖只有 CommonJS 格式产物而并未提供 ESM 产物，比如项目中用到 `lodash` 时，打包项目会出现这样的报错：

![Snipaste_2023-11-08_10-41-07.png](https://s2.loli.net/2023/11/08/P5GQo8kOnUtDwB2.png)

因此，我们需要引入额外的插件去解决这个问题。

首先需要安装两个核心的插件包:

```shell
pnpm i @rollup/plugin-node-resolve @rollup/plugin-commonjs
```

- `@rollup/plugin-node-resolve ` 是为了允许我们加载第三方依赖，否则像 `import React from 'react'` 的依赖导入语句将不会被 Rollup 识别。
- `@rollup/plugin-commonjs` 的作用是将 CommonJS 格式的代码转换为 ESM 格式

然后让我们在配置文件中导入这些插件:

```js
// rollup.config.js
import resolve from '@rollup/plugin-node-resolve'
import commonjs from '@rollup/plugin-commonjs'
/**
 * @type { import('rollup').RollupOptions }
 */
export default {
  input: ['src/index.js'],
  output: [
    {
      dir: 'dist/es',
      format: 'esm'
    },
    {
      dir: 'dist/cjs',
      format: 'cjs'
    }
  ],
  // 通过 plugins 参数添加插件
  plugins: [resolve(), commonjs()]
}
```

现在我们以 `lodash` 这个只有 CommonJS 产物的第三方包为例测试一下:

```shell
pnpm i lodash
```

在 `src/index.js` 加入如下的代码:

```js
import { merge } from 'lodash'

console.log(merge)
```

然后执行 npm run build ，你可以发现产物已经正常生成了：

![Snipaste_2023-11-08_10-49-23.png](https://s2.loli.net/2023/11/08/AjnbkUvi2qV1Gep.png)

在 Rollup 配置文件中， `plugins` 除了可以与 `output` 配置在同一级，也可以配置在 output 参数里面，如:

```js
// rollup.config.js
import { terser } from 'rollup-plugin-terser'
import resolve from '@rollup/plugin-node-resolve'
import commonjs from '@rollup/plugin-commonjs'
export default {
  output: {
    // 加入 terser 插件，用来压缩代码
    plugins: [terser()]
  },
  plugins: [resolve(), commonjs()]
}
```

> 当然，你可以将上述的 terser 插件放到最外层的 plugins 配置中。

需要注意的是， `output.plugins` 中配置的插件是有一定限制的，只有使用 `Output 阶段` 相关钩子(具体内容将在下一节展开)的插件才能够放到这个配置中，大家可以去[这个站点](https://github.com/rollup/awesome#output)查看 Rollup 的 Output 插件列表。

另外，这里也给大家分享其它一些比较常用的 Rollup 插件库:

- [@rollup/plugin-json](https://github.com/rollup/plugins/tree/master/packages/json)： 支持 `.json` 的加载，并配合 `rollup` 的 `Tree Shaking` 机制去掉未使用的部分，进行按需打包。
- [@rollup/plugin-babel](https://github.com/rollup/plugins/tree/master/packages/babel):在 Rollup 中使用 Babel 进行 JS 代码的语法转译。
- [@rollup/plugin-typescript](https://github.com/rollup/plugins/tree/master/packages/typescript): 支持使用 TypeScript 开发。
- [@rollup/plugin-alias](https://github.com/rollup/plugins/tree/master/packages/alias)：支持别名配置。
- [@rollup/plugin-replace](https://github.com/rollup/plugins/tree/master/packages/replace)：在 Rollup 进行变量字符串的替换。
- [rollup-plugin-visualizer](https://github.com/btd/rollup-plugin-visualizer): 对 Rollup 打包产物进行分析，自动生成产物体积可视化分析图。

#### JS API 方式调用

以上我们通过 `Rollup` 的配置文件结合 `rollup -c ` 完成了 Rollup 的打包过程，但有些场景下我们需要基于 Rollup 定制一些打包过程，配置文件就不够灵活了，这时候我们需要用到对应 JavaScript API 来调用 Rollup，主要分为 `rollup.rollup` 和 `rollup.watch` 两个 API，接下来我们以具体的例子来学习一下。

首先是 `rollup.rollup` ，用来一次性地进行 Rollup 打包，你可以新建 `build.js `，内容如下:

```js
// build.js
const rollup = require('rollup')
// 常用 inputOptions 配置
const inputOptions = {
  input: './src/index.js',
  external: [],
  plugins: []
}
const outputOptionsList = [
  // 常用 outputOptions 配置
  {
    dir: 'dist/es',
    entryFileNames: `[name].[hash].js`,
    chunkFileNames: 'chunk-[hash].js',
    assetFileNames: 'assets/[name]-[hash][extname]',
    format: 'es',
    sourcemap: true,
    globals: {
      lodash: '_'
    }
  }
  // 省略其它的输出配置
]
async function build() {
  let bundle
  let buildFailed = false
  try {
    // 1. 调用 rollup.rollup 生成 bundle 对象
    bundle = await rollup.rollup(inputOptions)
    for (const outputOptions of outputOptionsList) {
      // 2. 拿到 bundle 对象，根据每一份输出配置，调用 generate 和 write 方法分别生成和写入产物
      const { output } = await bundle.generate(outputOptions)
      await bundle.write(outputOptions)
    }
  } catch (error) {
    buildFailed = true
    console.error(error)
  }
  if (bundle) {
    // 最后调用 bundle.close 方法结束打包
    await bundle.close()
  }
  process.exit(buildFailed ? 1 : 0)
}
build()
```

主要的执行步骤如下：

- 通过 `rollup.rollup` 方法，传入 `inputOptions` ，生成 bundle 对象
- 调用 bundle 对象的 generate 和 write 方法，传入 `outputOptions` ，分别完成产物和生成和磁盘写入。
- 调用 bundle 对象的 close 方法来结束打包。

接着你可以执行 node build.js ，这样，我们就可以完成了以编程的方式来调用 Rollup 打包的过程。

除了通过 `rollup.rollup` 完成一次性打包，我们也可以通过 `rollup.watch` 来完成 `watch` 模式下的打包，即每次源文件变动后自动进行重新打包。你可以新建 `watch.js` 文件，内容入下:

```js
// watch.js
const rollup = require('rollup')
const watcher = rollup.watch({
  // 和 rollup 配置文件中的属性基本一致，只不过多了`watch`配置
  input: './src/index.js',
  output: [
    {
      dir: 'dist/es',
      format: 'esm'
    },
    {
      dir: 'dist/cjs',
      format: 'cjs'
    }
  ],
  watch: {
    exclude: ['node_modules/**'],
    include: ['src/**']
  }
})
// 监听 watch 各种事件
watcher.on('restart', () => {
  console.log('重新构建...')
})
watcher.on('change', id => {
  console.log('发生变动的模块id: ', id)
})
watcher.on('event', e => {
  if (e.code === 'BUNDLE_END') {
    console.log('打包信息:', e)
  }
})
```

现在你可以通过执行 node watch.js 开启 Rollup 的 watch 打包模式，当你改动一个文件后可以看到如下的日志，说明 Rollup 自动进行了重新打包，并触发相应的事件回调函数:

```txt
发生生变动的模块id: /xxx/src/index.js
重新构建...
打包信息: {
 code: 'BUNDLE_END',
 duration: 10,
 input: './src/index.js',
 output: [
 // 输出产物路径
 ],
 result: {
 cache: { /* 产物具体信息 */ },
 close: [AsyncFunction: close],
 closed: false,
 generate: [AsyncFunction: generate],
 watchFiles: [
 // 监听文件列表
 ],
 write: [AsyncFunction: write]
 }
}
```

基于如上的两个 JavaScript API 我们可以很方便地在代码中调用 Rollup 的打包流程，相比于配置文件有了更多的操作空间，你可以在代码中通过这些 API 对 Rollup 打包过程进行定制，甚至是二次开发。

### Rollup 插件机制

仅仅使用 Rollup 内置的打包能力很难满足项目日益复杂的构建需求。对于一个真实的项目构建场景来说，我们还需要考虑到 `模块打包` 之外的问题，比如路径别名(alias) 、全局变量注入和代码压缩等等。

可要是把这些场景的处理逻辑与核心的打包逻辑都写到一起，一来打包器本身的代码会变得十分臃肿，二来也会对原有的核心代码产生一定的侵入性，混入很多与核心流程无关的代码，不易于后期的维护。因此，Rollup 设计出了一套完整的 `插件机制`，将自身的核心逻辑与插件逻辑分离，让你能按需引入插件功能，提高了 Rollup 自身的可扩展性。

Rollup 的打包过程中，会定义一套完整的构建生命周期，从开始打包到产物输出，中途会经历一些 `标志性的阶段`，并且在不同阶段会自动执行对应的插件钩子函数(Hook)。对 Rollup 插件来讲，最重要的部分是钩子函数，一方面它定义了插件的执行逻辑，也就是"做什么"；另一方面也声明了插件的作用阶段，即"什么时候做"，这与 Rollup 本身的构建生命周期息息相关。

#### Rollup 整体构建阶段

在执行 `rollup` 命令之后，在 cli 内部的主要逻辑简化如下:

```js
// Build 阶段
const bundle = await rollup.rollup(inputOptions)
// Output 阶段
await Promise.all(outputOptions.map(bundle.write))
// 构建结束
await bundle.close()
```

Rollup 内部主要经历了 `Build` 和 `Output` 两大阶段：

![Snipaste_2023-11-08_11-23-16.png](https://s2.loli.net/2023/11/08/gLd7bPGlIJjwpCx.png)

首先，Build 阶段主要负责创建模块依赖图，初始化各个模块的 AST 以及模块之间的依赖关系。下面我们用一个简单的例子来感受一下:

```js
// src/index.js
import { a } from './module-a'
console.log(a)
// src/module-a.js
export const a = 1
```

然后执行如下的构建脚本:

```js
const rollup = require('rollup')
const util = require('util')
async function build() {
  const bundle = await rollup.rollup({
    input: ['./src/index.js']
  })
  console.log(util.inspect(bundle))
}
build()
```

可以看到这样的 bundle 对象信息：

```js
{
 cache: {
 modules: [
 {
 ast: 'AST 节点信息，具体内容省略',
 code: 'export const a = 1;',
 dependencies: [],
 id: '/Users/code/rollup-demo/src/data.js',
 // 其它属性省略
 },
 {
 ast: 'AST 节点信息，具体内容省略',
 code: "import { a } from './data';\n\nconsole.log(a);",
 dependencies: [
 '/Users/code/rollup-demo/src/data.js'
 ],
 id: '/Users/code/rollup-demo/src/index.js',
 // 其它属性省略
 }
 ],
 plugins: {}
 },
 closed: false,
 // 挂载后续阶段会执行的方法
 close: [AsyncFunction: close],
 generate: [AsyncFunction: generate],
 write: [AsyncFunction: write]
}
```

从上面的信息中可以看出，目前经过 Build 阶段的 `bundle` 对象其实并没有进行模块的打包，这个对象的作用在于存储各个模块的内容及依赖关系，同时暴露 `generate` 和 `write` 方法，以进入到后续的 `Output` 阶段（ `write` 和 `generate` 方法唯一的区别在于前者打包完产物会写入磁盘，而后者不会）。

所以，真正进行打包的过程会在 `Output` 阶段进行，即在 `bundle` 对象的 `generate` 或者 `write` 方法中进行。还是以上面的 demo 为例，我们稍稍改动一下构建逻辑:

```js
const rollup = require('rollup')
async function build() {
  const bundle = await rollup.rollup({
    input: ['./src/index.js']
  })
  const result = await bundle.generate({
    format: 'es'
  })
  console.log('result:', result)
}
build()
```

执行后可以得到如下的输出:

```js
{
  output: [
    {
      exports: [],
      facadeModuleId: '/Users/code/rollup-demo/src/index.js',
      isEntry: true,
      isImplicitEntry: false,
      type: 'chunk',
      code: 'const a = 1;\n\nconsole.log(a);\n',
      dynamicImports: [],
      fileName: 'index.js'
      // 其余属性省略
    }
  ]
}
```

这里可以看到所有的输出信息，生成的 `output` 数组即为打包完成的结果。当然，如果使用 `bundle.write` 会根据配置将最后的产物写入到指定的磁盘目录中。

因此，**对于一次完整的构建过程而言， Rollup 会先进入到 Build 阶段，解析各模块的内容及依赖关系，然后进入 `Output` 阶段，完成打包及输出的过程**。对于不同的阶段，Rollup 插件会有不同的插件工作流程，接下来我们就来拆解一下 Rollup 插件在 Build 和 Output 两个阶段的详细工作流程。

#### 拆解插件工作流

##### 谈谈插件 Hook 类型

在具体讲述 Rollup 插件工作流之前，我想先给大家介绍一下不同插件 Hook 的类型，这些类型代表了不同插件的执行特点，是我们理解 Rollup 插件工作流的基础，因此有必要跟大家好好拆解一下。

通过上文的例子，相信你可以直观地理解 Rollup 两大构建阶段（ `Build` 和 `Output` ）各自的原理。可能你会有疑问，这两个阶段到底跟插件机制有什么关系呢？实际上，插件的各种 Hook 可以根据这两个构建阶段分为两类: `Build Hook ` 与 `Output Hook` 。

- `Build Hook` 即在 `Build` 阶段执行的钩子函数，在这个阶段主要进行模块代码的转换、AST 解析以及模块依赖的解析，那么这个阶段的 Hook 对于代码的操作粒度一般为 `模块` 级别，也就是单文件级别。
- `Ouput Hook` (官方称为 `Output Generation Hook` )，则主要进行代码的打包，对于代码而言，操作粒度一般为 chunk 级别(一个 `chunk` 通常指很多文件打包到一起的产物)

除了根据构建阶段可以将 Rollup 插件进行分类，根据不同的 Hook 执行方式也会有不同的分类，主要包括 `Async` 、 `Sync` 、 `Parallel` 、 `Squential` 、 `First` 这五种。在后文中我们将接触各种各样的插件 Hook，但无论哪个 Hook 都离不开这五种执行方式。

###### 1.Async&Sync

首先是 `Async` 和 `Sync` 钩子函数，两者其实是相对的，分别代表 `异步` 和 `同步` 的钩子函数，两者最大的区别在于同步钩子里面不能有异步逻辑，而异步钩子可以有。

###### 2.Parallel

这里指并行的钩子函数。如果有多个插件实现了这个钩子的逻辑，一旦有钩子函数是异步逻辑，则并发执行钩子函数，不会等待当前钩子完成(底层使用 Promise.all )。

比如对于 `Build` 阶段的 `buildStart` 钩子，它的执行时机其实是在构建刚开始的时候，各个插件可以在这个钩子当中做一些状态的初始化操作，但其实插件之间的操作并不是相互依赖的，也就是可以并发执行，从而提升构建性能。反之，对于需要依赖其他插件处理结果的情况就不适合用 `Parallel` 钩子了，比如 `transform` 。

###### 3.Sequential

**Sequential** 指串行的钩子函数。这种 Hook 往往适用于插件间处理结果相互依赖的情况，前一个插件 Hook 的返回值作为后续插件的入参，这种情况就需要等待前一个插件执行完 Hook，获得其执行结果，然后才能进行下一个插件相应 Hook 的调用，如 `transform` 。

###### 4.First

如果有多个插件实现了这个 Hook，那么 Hook 将依次运行，直到返回一个非 null 或非 undefined 的值为止。比较典型的 Hook 是 `resolveId` ，一旦有插件的 resolveId 返回一个路径，将停止执行后续插件的 resolveId 逻辑。

刚刚我们介绍了 Rollup 当中不同插件 Hook 的类型，实际上不同的类型是可以叠加的， `Async` / `Sync` 可以搭配后面三种类型中的任意一种，比如一个 Hook 既可以是 `Async` 也可以是 `First` 类型，接着我们将来具体分析 Rollup 当中的插件工作流程，里面会涉及到具体的一些 Hook，大家可以具体地感受一下。

##### Build 阶段工作流

首先，我们来分析 Build 阶段的插件工作流程。对于 Build 阶段，插件 Hook 的调用流程如下图所示。流程图的最上面声明了不同 Hook 的类型，也就是我们在上面总结的 5种 Hook 分类，每个方块代表了一个 Hook，边框的颜色可以表示 Async 和 Sync 类型，方块的填充颜色可以表示 `Parallel` 、 `Sequential` 和 `First` 类型。

![图片.png](https://s2.loli.net/2023/11/08/V8mzwpK1WXkrRTh.png)

乍一看是不是感觉这张图非常复杂？没关系，接下来我会和你一步步分析 `Build Hooks` 的工作流程，你可以对照着图一起看。

- 首先经历 `options` 钩子进行配置的转换，得到处理后的配置对象。
- 随之 Rollup 会调用 `buildStart` 钩子，正式开始构建流程。
- Rollup 先进入到 `resolveId` 钩子中解析文件路径。(从 `input` 配置指定的入口文件开始)。
- Rollup 通过调用 `load` 钩子加载模块内容。
- 紧接着 Rollup 执行所有的 `transform` 钩子来对模块内容进行进行自定义的转换，比如 babel 转译。
- 现在 Rollup 拿到最后的模块内容，进行 AST 分析，得到所有的 import 内容，调用 moduleParsed 钩子:
  - **6.1** 如果是普通的 import，则执行 `resolveId` 钩子，继续回到步骤 3 。
  - **6.2** 如果是动态 import，则执行 `resolveDynamicImport` 钩子解析路径，如果解析成功，则回到步骤 `4` 加载模块，否则回到步骤 `3` 通过 `resolveId` 解析路径。
- 直到所有的 import 都解析完毕，Rollup 执行 buildEnd 钩子，Build 阶段结束。

当然，在 Rollup 解析路径的时候，即执行 `resolveId` 或者 `resolveDynamicImport` 的时候，有些路径可能会被标记为 `external` (翻译为 `排除` )，也就是说不参加 Rollup 打包过程，这个时候就不会进行 `load` 、 `transform` 等等后续的处理了。

在流程图最上面，不知道大家有没有注意到 `watchChange` 和 `closeWatcher` 这两个 Hook，这里其实是对应了 rollup 的 `watch` 模式。当你使用 `rollup --watch` 指令或者在配置文件配有 `watch: true` 的属性时，代表开启了 Rollup 的 `watch` 打包模式，这个时候 Rollup 内部会初始化一个 `watcher` 对象，当文件内容发生变化时，watcher 对象会自动触发 `watchChange` 钩子执行并对项目进行重新构建。在当前打包过程结束时，Rollup 会自动清除 watcher 对象调用 `closeWacher` 钩子。

##### Output 阶段工作流

好，接着我们来看看 Output 阶段的插件到底是如何来进行工作的。这个阶段的 Hook 相比于 Build 阶段稍微多一些，流程上也更加复杂。需要注意的是，其中会涉及的 Hook 函数比较多，可能会给你理解整个流程带来一些困扰，因此我会在 Hook 执行的阶段解释其大致的作用和意义，关于具体的使用大家可以去 Rollup 的官网自行查阅，毕竟这里的主线还是分析插件的执行流程，掺杂太多的使用细节反而不易于理解。下面我结合一张完整的插件流程图和你具体分析一下：

![dsadasddasdjlask.png](https://s2.loli.net/2023/11/08/JQXedf4gNlxFYrc.png)

![dsadsadsafe.png](https://s2.loli.net/2023/11/08/QxcDwsAOrlzmqdL.png)

执行所有插件的 `outputOptions` 钩子函数，对 `output` 配置进行转换。

执行 `renderStart` ，并发执行 renderStart 钩子，正式开始打包。

并发执行所有插件的 `banner` 、 `footer` 、 `intro` 、 `outro` 钩子(底层用 Promise.all 包裹所有的这四种钩子函数)，这四个钩子功能很简单，就是往打包产物的固定位置(比如头部和尾部)插入一些自定义的内容，比如协议声明内容、项目介绍等等。

从入口模块开始扫描，针对动态 import 语句执行 `renderDynamicImport` 钩子，来自定义动态 import 的内容
